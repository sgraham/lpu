#
# This file is definition for opcodes for documentation purposes, but also
# for the assembler, disassembler, and simulator.
#
# the register and memory operations are specified with bit ranges from high to low.
#
# user registers are A, D, P, all 16 bits
# inaccessible registers: HEAP (12 bits), SCAN (12 bits), HS (1 bit), IP (14 bits), INSTR (8 bits)
#   (SCAN is pseudo-accessible, but not very useful and is volatile across cons/gc.)
#

00000000 nop
00000001 car
    A[7-0] = MEM[P[b-0]*4][7-0]
    A[f-8] = MEM[P[b-0]*4+1][7-0]
00000010 cdr
    D[7-0] = MEM[P[b-0]*4+2][7-0]
    D[f-8] = MEM[P[b-0]*4+3][7-0]
00000011 load
    A[7-0] = MEM[P[b-0]*4][7-0]
    A[f-8] = MEM[P[b-0]*4+1][7-0]
    D[7-0] = MEM[P[b-0]*4+2][7-0]
    D[f-8] = MEM[P[b-0]*4+3][7-0]
00000100 cons
    if HEAP == 0:
        CDR(GC1) = IP
        IP = CAR(GC1)
    else:
        HEAP -= 1
        CAR(HEAP) = NIL
        CDR(HEAP) = P
        P = HEAP
00000101 rplaca
    MEM[P[b-0]*4][7-0] = A[7-0]
    MEM[P[b-0]*4+1][7-0] = A[f-8]
00000110 rplacd
    MEM[P[b-0]*4+2][7-0] = D[7-0]
    MEM[P[b-0]*4+3][7-0] = D[f-8]
00000111 rplacb
    MEM[P[b-0]*4][7-0] = A[7-0]
    MEM[P[b-0]*4+1][7-0] = A[f-8]
    MEM[P[b-0]*4+2][7-0] = D[7-0]
    MEM[P[b-0]*4+3][7-0] = D[f-8]

00001000 ?
00001001 ?
00001010 ?
00001100 ?
00001101 ?
00001110 ?
00001111 ?

00010000 add
    A[b-0] = A[b-0] + D[b-0]
00010001 inc
    A[b-0] = A[b-0] + 1
00010010 xor
    A[b-0] = A[b-0] ^ D[b-0]
00010011 not
    A[b-0] = ~A[b-0]
00010100 and
    A[b-0] = A[b-0] & D[b-0]
00010101 or
    A[b-0] = A[b-0] | D[b-0]
00010110 shl
    A[b-0] = A[b-0] << 1
00010111 shr
    A[b-0] = A[b-0] >> 1

00011000 AtoD
    D[f-0] = A[f-0]
00011001 DtoA
    A[f-0] = D[f-0]
00011010 AtoP
    P[f-0] = A[f-0]
00011011 PtoA
    A[f-0] = P[f-0]
00011100 DtoP
    P[f-0] = D[f-0]
00011101 PtoD
    D[f-0] = P[f-0]
00011110 swapAD
    tmp = A[f-0]
    A[f-0] = D[f-0]
    D[f-0] = tmp
00011111 swapAP
    tmp = A[f-0]
    A[f-0] = P[f-0]
    P[f-0] = tmp

00100000 decA
    A[b-0] = A[b-0] - 1
00100001 decP
    P[b-0] = P[b-0] - 1
00100010 ?
00100011 ?
00100100 isatom
    A[f-0] = ~A[f-f]
00100100 putc
00100110 lt
00100111 j
    IP = A[b-0]*4

# GC helpers
00101000 togglehs
    HS = HS ^ 1
00101001 resetheap
    HEAP = cdr(GC1)
00101010 isbh
    A[f-0] = A[e-e]
00101011 setbh
    MEM[P[b-0]*4][7-7] = 1          # set top bit of car of P
    MEM[P[b-0]*4][3-0] = A[b-8]     # store A as ptr to new HS
    MEM[P[b-0]*4+1][7-0] = A[7-0]
00101100 freecells
    A[b-0] = HEAP
    A[f-c] = 0                      # 0 == fixnum tag
00101101 DtoAlo
    A[b-0] = D[b-0]                 # todo; this instr seems very lame
00101110 ?
00101111 ?

0011xxxx setty N
    A[f-c] = INSTR[3-0]

01xxxxxx jz L
    # todo; sign extension
    IP = IP + INSTR[5-0]

10xxxxxx immlo N
    A[5-0] = INSTR[5-0]
    A[b-6] = 0 # todo; want this?

11xxxxxx immhi N
    A[b-6] = INSTR[5-0]

# vim: set ft=asm:
